（1）第一次delete某个指针后，该指针仍然存在，并且里面的地址值并没有发生什么变化，但是它指向的那个对象的空间发生了还原（初始化）。
int * it=new int(32);
delete it
cout<<*it;
结果为0。
*it+=1；
cout<<*it;
结果为1。
(2)虽然是这样，但是如果你这个时候第二次使用delete去释放该指针指向的对象时，出现我们所熟悉的两次释放错误。
delete it;
系统崩溃。
（3）绝对不能释放不是由new申请的空间，这个与使用哪个指针去释放没有关系（事实上指针不会发生任何变化），只要对应对象是建设在栈上面就不行。
(4)从上面可以看出，使用delete释放空间的时候，对指针没有做任何的检查和处理，释放前和释放后指针不会发生变化。释放的时候出现错误（1，二次释放；2，释放栈），完全是因为检查释放对象的问题。第一次释放成功后该空间注册为空闲的，但是指针仍然指向那个位置，仍然可以进行加，这是指针的恐怖之处。也就是说，delete并检查释放的是空闲的地址（在系统中注册了）就会报错。
（5）根据前面的操作发现，释放是将指针指向的空间设为free，而不会对指针本身有任何的处理的，所以这个时候指针是有值的，而且指向了一个非法的地方，这个时候系统并不能做出检测，所以我们最好在释放一个空间之后，将该指针付NULL，或者是一个合法的地址。
（6）前面分析，free只检查指针指向的地址是不是堆上的被申请的地址，如果成功则合法，但是free一个堆上对象的一个成员，是一个很危险的事情，因为你这样free意味者，那个堆上对象被你打了一个洞，这个洞部分已经是属于系统了，这个动作会成功，但是如果你才次调用free（或delete）删除整个堆对象想则报出二次释放错误。所以，千万不要释放直接通过new申请的空间。
 